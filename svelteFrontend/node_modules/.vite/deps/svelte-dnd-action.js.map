{
  "version": 3,
  "sources": ["../../svelte-dnd-action/src/helpers/dispatcher.js", "../../svelte-dnd-action/src/constants.js", "../../svelte-dnd-action/src/helpers/intersection.js", "../../svelte-dnd-action/src/helpers/listUtil.js", "../../svelte-dnd-action/src/helpers/scroller.js", "../../svelte-dnd-action/src/helpers/util.js", "../../svelte-dnd-action/src/helpers/observer.js", "../../svelte-dnd-action/src/helpers/windowScroller.js", "../../svelte-dnd-action/src/helpers/svelteNodeClone.js", "../../svelte-dnd-action/src/helpers/styler.js", "../../svelte-dnd-action/src/pointerAction.js", "../../svelte-dnd-action/src/helpers/aria.js", "../../svelte-dnd-action/src/keyboardAction.js", "../../svelte-dnd-action/src/action.js"],
  "sourcesContent": ["// external events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(FINALIZE_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(CONSIDER_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n// internal events\nexport const DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nexport const DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nexport const DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nexport const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\n\nexport const DRAGGED_LEFT_TYPES = {\n    LEFT_FOR_ANOTHER: \"leftForAnother\",\n    OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\n\nexport function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nexport function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}\n        })\n    );\n}\n\nexport function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}\n        })\n    );\n}\nexport function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\nexport function dispatchDraggedLeftDocument(draggedEl) {\n    window.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n            detail: {draggedEl}\n        })\n    );\n}\n", "import {DRAGGED_ENTERED_EVENT_NAME, DRAGGED_LEFT_EVENT_NAME, DRAGGED_OVER_INDEX_EVENT_NAME} from \"./helpers/dispatcher\";\n\nexport const TRIGGERS = {\n    DRAG_STARTED: \"dragStarted\",\n    DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n    DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n    DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n    DROPPED_INTO_ZONE: \"droppedIntoZone\",\n    DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n    DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n    DRAG_STOPPED: \"dragStopped\"\n};\n\nexport const SOURCES = {\n    POINTER: \"pointer\",\n    KEYBOARD: \"keyboard\"\n};\n\nexport const SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nexport const SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item\";\nexport const SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nexport const DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\n\nexport let ITEM_ID_KEY = \"id\";\nlet activeDndZoneCount = 0;\nexport function incrementActiveDropZoneCount() {\n    activeDndZoneCount++;\n}\nexport function decrementActiveDropZoneCount() {\n    if (activeDndZoneCount === 0) {\n        throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n    }\n    activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nexport function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n    if (activeDndZoneCount > 0) {\n        throw new Error(\"can only override the id key before initialising any dndzone\");\n    }\n    if (typeof newKeyName !== \"string\") {\n        throw new Error(\"item id key has to be a string\");\n    }\n    printDebug(() => [\"overriding item id key name\", newKeyName]);\n    ITEM_ID_KEY = newKeyName;\n}\n\nexport const isOnServer = typeof window === \"undefined\";\n\nexport let printDebug = () => {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {Boolean} isDebug\n */\nexport function setDebugMode(isDebug) {\n    if (isDebug) {\n        printDebug = (generateMessage, logFunction = console.debug) => {\n            const message = generateMessage();\n            if (Array.isArray(message)) {\n                logFunction(...message);\n            } else {\n                logFunction(message);\n            }\n        };\n    } else {\n        printDebug = () => {};\n    }\n}\n", "// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getBoundingRectNoTransforms(el) {\n    let ta;\n    const rect = el.getBoundingClientRect();\n    const style = getComputedStyle(el);\n    const tx = style.transform;\n\n    if (tx) {\n        let sx, sy, dx, dy;\n        if (tx.startsWith(\"matrix3d(\")) {\n            ta = tx.slice(9, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[5];\n            dx = +ta[12];\n            dy = +ta[13];\n        } else if (tx.startsWith(\"matrix(\")) {\n            ta = tx.slice(7, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[3];\n            dx = +ta[4];\n            dy = +ta[5];\n        } else {\n            return rect;\n        }\n\n        const to = style.transformOrigin;\n        const x = rect.x - dx - (1 - sx) * parseFloat(to);\n        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n        const w = sx ? rect.width / sx : el.offsetWidth;\n        const h = sy ? rect.height / sy : el.offsetHeight;\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            top: y,\n            right: x + w,\n            bottom: y + h,\n            left: x\n        };\n    } else {\n        return rect;\n    }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRectNoTransforms(el) {\n    const rect = getBoundingRectNoTransforms(el);\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRect(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n    return {\n        x: (rect.left + rect.right) / 2,\n        y: (rect.top + rect.bottom) / 2\n    };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nexport function isPointInsideRect(point, rect) {\n    return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n    return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @return {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const rectOfB = getAbsoluteRectNoTransforms(elB);\n    return isPointInsideRect(centerOfA, rectOfB);\n}\n\n/**\n * @param {HTMLElement|ChildNode} elA\n * @param {HTMLElement|ChildNode} elB\n * @return {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const centerOfB = findCenterOfElement(elB);\n    return calcDistance(centerOfA, centerOfB);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nexport function isElementOffDocument(el) {\n    const rect = getAbsoluteRect(el);\n    return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nexport function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    const rect = getAbsoluteRect(el);\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        // TODO - figure out what is so special about right (why the rect is too big)\n        right: Math.min(rect.right, document.documentElement.clientWidth) - point.x\n    };\n}\n", "import {isCenterOfAInsideB, calcDistanceBetweenCenters, getAbsoluteRectNoTransforms, isPointInsideRect, findCenterOfElement} from \"./intersection\";\nimport {printDebug, SHADOW_ELEMENT_ATTRIBUTE_NAME} from \"../constants\";\n\nlet dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nexport function resetIndexesCache() {\n    printDebug(() => \"resetting indexes cache\");\n    dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution for a specific dropzone, should be called after the zone was scrolled\n * @param {HTMLElement} dz\n */\nexport function resetIndexesCacheForDz(dz) {\n    printDebug(() => \"resetting indexes cache for dz\");\n    dzToShadowIndexToRect.delete(dz);\n}\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n    const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n    if (shadowElIndex >= 0) {\n        if (!dzToShadowIndexToRect.has(dz)) {\n            dzToShadowIndexToRect.set(dz, new Map());\n        }\n        dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n        return shadowElIndex;\n    }\n    return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n    if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n        return null;\n    }\n    const children = collectionBelowEl.children;\n    // the container is empty, floating element should be the first\n    if (children.length === 0) {\n        return {index: 0, isProximityBased: true};\n    }\n    const shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n    // the search could be more efficient but keeping it simple for now\n    // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n    for (let i = 0; i < children.length; i++) {\n        if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n            const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n            if (cachedShadowRect) {\n                if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {\n                    return {index: shadowElIndex, isProximityBased: false};\n                }\n            }\n            return {index: i, isProximityBased: false};\n        }\n    }\n    // this can happen if there is space around the children so the floating element has\n    //entered the container but not any of the children, in this case we will find the nearest child\n    let minDistanceSoFar = Number.MAX_VALUE;\n    let indexOfMin = undefined;\n    // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n    for (let i = 0; i < children.length; i++) {\n        const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n        if (distance < minDistanceSoFar) {\n            minDistanceSoFar = distance;\n            indexOfMin = i;\n        }\n    }\n    return {index: indexOfMin, isProximityBased: true};\n}\n", "import {calcInnerDistancesBetweenPointAndSidesOfElement} from \"./intersection\";\nconst SCROLL_ZONE_PX = 25;\n\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        if (distances === null) {\n            resetScrolling();\n            return false;\n        }\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n", "/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "import {findWouldBeIndex, resetIndexesCache, resetIndexesCacheForDz} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {makeScroller} from \"./scroller\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            if (scrolled) resetIndexesCacheForDz(lastDropZoneFound);\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetScrolling();\n    resetIndexesCache();\n}\n", "import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\nimport {resetIndexesCache} from \"./listUtil\";\n\nconst INTERVAL_MS = 300;\nlet mousePosition;\n\n/**\n * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners\n * // TODO - make private (remove export)\n * @param {{clientX: number, clientY: number}} e\n */\nexport function updateMousePosition(e) {\n    const c = e.touches ? e.touches[0] : e;\n    mousePosition = {x: c.clientX, y: c.clientY};\n}\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\nfunction loop() {\n    if (mousePosition) {\n        const scrolled = scrollIfNeeded(mousePosition, document.documentElement);\n        if (scrolled) resetIndexesCache();\n    }\n    next = window.setTimeout(loop, INTERVAL_MS);\n}\n\n/**\n * will start watching the mouse pointer and scroll the window if it goes next to the edges\n */\nexport function armWindowScroller() {\n    printDebug(() => \"arming window scroller\");\n    window.addEventListener(\"mousemove\", updateMousePosition);\n    window.addEventListener(\"touchmove\", updateMousePosition);\n    loop();\n}\n\n/**\n * will stop watching the mouse pointer and won't scroll the window anymore\n */\nexport function disarmWindowScroller() {\n    printDebug(() => \"disarming window scroller\");\n    window.removeEventListener(\"mousemove\", updateMousePosition);\n    window.removeEventListener(\"touchmove\", updateMousePosition);\n    mousePosition = undefined;\n    window.clearTimeout(next);\n    resetScrolling();\n}\n", "/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n * \n * @param {HTMLElement} el \n * @returns \n */\nexport function svelteNodeClone(el) {\n  const cloned = el.cloneNode(true);\n\n  const values = [];\n  const elIsSelect = el.tagName === \"SELECT\";\n  const selects = elIsSelect ? [el] : [...el.querySelectorAll('select')];\n  for (const select of selects) {\n    values.push(select.value);\n  }\n\n  if (selects.length <= 0) {\n    return cloned;\n  }\n\n  const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll('select')];\n  for (let i = 0; i < clonedSelects.length; i++) {\n    const select = clonedSelects[i];\n    const value = values[i];\n    const optionEl = select.querySelector(`option[value=\"${value}\"`);\n    if (optionEl) {\n      optionEl.setAttribute('selected', true);\n    }\n  }\n\n  return cloned;\n}\n", "import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport {svelteNodeClone} from \"./svelteNodeClone\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n    copyStylesFromTo(copyFromEl, draggedEl);\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        draggedEl.style.height = `${newRect.height}px`;\n        draggedEl.style.width = `${newRect.width}px`;\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\"\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n", "import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {armWindowScroller, disarmWindowScroller} from \"./helpers/windowScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    armWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const observationIntervalMs = Math.max(\n        MIN_OBSERVATION_INTERVAL_MS,\n        ...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs)\n    );\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    disarmWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    unobserve();\n}\n\n// finds the initial placeholder that is placed there on drag start\nfunction findShadowPlaceHolderIdx(items) {\n    return items.findIndex(item => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);\n}\nfunction findShadowElementIdx(items) {\n    // checking that the id is not the placeholder's for Dragula like usecases\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    } else {\n        const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);\n        if (shadowPlaceHolderIdx !== -1) {\n            // only happens right after drag start, on the first drag entered event\n            printDebug(() => \"removing placeholder item from origin dz\");\n            items.splice(shadowPlaceHolderIdx, 1);\n        }\n    }\n\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const shadowElIdx = findShadowElementIdx(items);\n    const shadowItem = items.splice(shadowElIdx, 1)[0];\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        originZoneItems.splice(originIndex, 0, shadowItem);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    items.splice(shadowElIdx, 1);\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) shadowElIdx = originIndex;\n    items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);\n        cleanupPostDrop();\n    }\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    draggedEl.remove();\n    originalDragTarget.remove();\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        });\n        scheduledForRemovalAfterDrop = [];\n    }\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n    }\n    function handleFalseAlarm() {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        e.preventDefault();\n        const c = e.touches ? e.touches[0] : e;\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        e.stopPropagation();\n        const c = e.touches ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument} */\n        const rootNode = originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items, type, centreDraggedOnCursor} = config;\n        draggedElData = {...items[currentIdx]};\n        draggedElType = type;\n        shadowElData = {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true};\n        // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues\n        const placeHolderElData = {...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!draggedEl.parentElement) {\n                originDropZoneRoot.appendChild(draggedEl);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                originDropZoneRoot.appendChild(originalDragTarget);\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, placeHolderElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        const shadowElIdx = findShadowElementIdx(config.items);\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                config.transformDraggedElement(draggedEl, draggedElData, idx);\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n                }\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n                destroyDz();\n            }\n        }\n    };\n}\n", "import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n", "import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = 0;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : 0;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = 0;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n", "import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n}\n\nfunction isInt(value) {\n    return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value));\n}\n"],
  "mappings": "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",
  "names": ["draggedEl", "resetScrolling", "scrollIfNeeded", "draggedEl", "INTERVAL_MS", "scrollIfNeeded", "resetScrolling", "next", "draggedEl", "DEFAULT_DROP_ZONE_TYPE", "DEFAULT_DROP_TARGET_STYLE", "dzToConfig", "typeToDropZones", "INSTRUCTION_IDs", "registerDropZone", "unregisterDropZone", "handleDrop", "dndzone", "dndzone"]
}
